<!doctype html>
<html lang="en">
<head>
	<title>Frisbee Golf</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body>

<script src="js/Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src='js/threex.grass.js'></script>

<script type='text/javascript' src='js/DAT.GUI.min.js'></script>


<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>


// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
// custom global variables
var model = null;

var modelDirectory = "models/";
var disc;
var pyramid;

var ychange = 1;
var gravity = 2;
var powerdisc = 50;
var directionAngle = 0;
var tiltAngle = 0;
var wind = 0;
var gameNotOver = true;
var level1 = true;


init();
animate();
// while (gameNotOver){
// 	while (level1){
// 		if (disc.position == model.positions){
// 			alert("You made it in the hole!");
// 			break;
// 		}
// 		else if (disc.position.y == -3){
// 			alert("Take another throw");
// 			disc.position.y = 40;
// 			//move camera
// 		}
// 	}
// }



// FUNCTIONS 		
function init() 
{
	// SCENE
	scene = new THREE.Scene();
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(0,50,2000);
	camera.lookAt(scene.position);	
	// RENDERER
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
		renderer = new THREE.CanvasRenderer(); 
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	// LIGHT
	var light = new THREE.PointLight(0xffffff);
	light.position.set(0,1250,0);
	scene.add(light);
	//ambient light
	var light2 = new THREE.AmbientLight(0x333333); 
	light2.position.set( light.position );
	scene.add(light2);
	// FLOOR
	THREE.ImageUtils.crossOrigin = '';
	var floorTexture = THREE.ImageUtils.loadTexture('images/grass-512.jpg');
	// var floorTexture = new THREE.ImageUtils.loadTexture( 'images/grass.jpg' );
	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
	floorTexture.repeat.set( 10, 10 );
	var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneGeometry(5000, 5000, 10, 10);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.position.y = -5;
	floor.rotation.x = Math.PI / 2;
	scene.add(floor);


	////////////
	// CUSTOM //
	////////////
	
	// axes
	var axes = new THREE.AxisHelper(100);
	scene.add( axes );

	//3d grass
	var nTufts	= 5000
	var positions	= new Array(nTufts)
	for(var i = 0; i < nTufts; i++){
		var gposition	= new THREE.Vector3()
		gposition.x	= (Math.random()-0.5)*20
		gposition.z	= (Math.random()-0.5)*20
		positions[i]	= gposition
	}
	var mesh	= THREEx.createGrassTufts(positions)
	scene.add(mesh)

	// load the texture
	var textureUrl		= THREEx.createGrassTufts.baseUrl+'images/grass01.png'
	var material		= mesh.material
	material.map		= THREE.ImageUtils.loadTexture(textureUrl)
	material.alphaTest	= 0.7

	//skybox

	var imagePrefix = "images/nightsky_";
	var imagePrefixDay = "images/dawnmountain-";
	var directions  = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
	var imageSuffix = ".png";
	var skyGeometry = new THREE.CubeGeometry( 5000, 5000, 5000 );

	var materialArray = [];
	for (var i = 0; i < 6; i++)
		materialArray.push( new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
			side: THREE.BackSide
		}));
	var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
	var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
	scene.add( skyBox );
	
	var materialArrayDay = [];
	for (var i = 0; i < 6; i++)
		materialArrayDay.push( new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture( imagePrefixDay + directions[i] + imageSuffix ),
			side: THREE.BackSide
		}));
	var skyMaterialDay = new THREE.MeshFaceMaterial( materialArrayDay );
	var skyBoxDay = new THREE.Mesh( skyGeometry, skyMaterialDay );
	scene.add( skyBoxDay );

	var shapeMaterial = new THREE.MeshPhongMaterial( { color:0xff0000, transparent:true, opacity:1 } );

	var shapeMaterial = new THREE.MeshPhongMaterial( { color:0xff0000, transparent:false, opacity:1 } );

	
	//add frisbee stuff
	installModel(0);


	var geometry = new THREE.CylinderGeometry( 10, 10, 1, 60 );
	var material = new THREE.MeshLambertMaterial( {color: 0xffff00} );
    disc = new THREE.Mesh( geometry, material );
	disc.position.set(0,40,1900);
	scene.add( disc );

	// pyramid
	pyramid = new THREE.Mesh( 
		// radiusAtTop, radiusAtBottom, height, segmentsAroundRadius, segmentsAlongHeight,
		new THREE.CylinderGeometry( 0, 5, 80, 3, 4 ), 
		shapeMaterial );
	pyramid.position.set(0, 3, -50);
	pyramid.rotateOnAxis( new THREE.Vector3(1,0,0), 275);
	disc.add( pyramid );

	var gui = new dat.GUI();
	var parameters = 
	{
		a: 0, // numeric slider
		p: 50, //numeric slider
		b: false, //boolean (checkbox)
		c: true, // boolean (checkbox)
		d: "#ffff00", // color (hex)
		x: 0, y: 0, z: 0
	};
	// gui.add( parameters )
	var winds = gui.add( parameters, 'a' ).min(0).max(50).step(5).name('Wind').listen();
	winds.onChange( function(value) {
		wind = value;
	})

	var power = gui.add( parameters, 'p').min(0).max(70).step(5).name('Power').listen();
	power.onChange( function(value) {
		powerdisc = value;
	});

	var daysky = gui.add( parameters, 'b').name("Day Mode").listen();
	daysky.onChange( function(value) {
		
		if(value) {
			scene.remove( skyBox);
			nightsky.setValue(false);
			scene.add( skyBoxDay)
		}
	});

	var nightsky = gui.add( parameters, 'c').name('Night Mode').listen();
	nightsky.onChange( function(value) {
		if (value) {
			scene.remove( skyBoxDay);
			daysky.setValue(false);
			scene.add( skyBox);
		}
	});

	var discColor = gui.addColor( parameters, 'd' ).name('Disc Color').listen();
	discColor.onChange(function(value)
	{disc.material.color.setHex( value.replace("#", "0x") );  });
	
	var folder1 = gui.addFolder('Coordinates');
	folder1.add( parameters, 'x' );
	folder1.add( parameters, 'y' );
	folder1.add( parameters, 'z' );
	folder1.close();




	gui.open();
	
}


function installModel(modelNumber) {
    function callback(geometry,material) {  // callback function to be executed when loading finishes.
        modelLoaded(geometry, [0,0,0]);
        //document.getElementById("status").innerHTML = "";
        
    }
    if (model) {
        scene.remove(model);
    }
    //document.getElementById("status").innerHTML = "Loading<br>" + "frisbee.json";
    var loader = new THREE.JSONLoader();
    try {
        loader.load(modelDirectory + "frishole.json", callback);
    }
    catch (e) {
        // Note: Will give an error if loading from the local file system
        // on some browsers (Chrome, at least). 
        document.getElementById("status").innerHTML =
            "Could not<br>load model!<br><br>Note that<br>some browsers<br>cannot load<br>models from<br>a local disk.";
    }
}

function modelLoaded(geometry, rotation) {

    /* create the object from the geometry was loaded, with a white material. */
       
    var object = new THREE.Mesh(geometry,
                        new THREE.MeshLambertMaterial( {color:"white"} ));

    /* Determine the ranges of x, y, and z in the vertices of the geometry. */

    var xmin = Infinity;
    var xmax = -Infinity;
    var ymin = Infinity;
    var ymax = -Infinity;
    var zmin = Infinity;
    var zmax = -Infinity;
    for (var i = 0; i < geometry.vertices.length; i++) {
        var v = geometry.vertices[i];
        if (v.x < xmin)
            xmin = v.x;
        else if (v.x > xmax)
            xmax = v.x;
        if (v.y < ymin)
            ymin = v.y;
        else if (v.y > ymax)
            ymax = v.y;
        if (v.z < zmin)
            zmin = v.z;
        else if (v.z > zmax)
            zmax = v.z;
    }
    
    /* translate the center of the object to the origin */
    var centerX = (xmin+xmax)/2;
    var centerY = (ymin+ymax)/2; 
    var centerZ = (zmin+zmax)/2;
    var max = Math.max(centerX - xmin, xmax - centerX);
    max = Math.max(max, Math.max(centerY - ymin, ymax - centerY) );
    max = Math.max(max, Math.max(centerZ - zmin, zmax - centerZ) );
    var scale = 50/max;
    object.position.set( -centerX, -centerY+1, -centerZ+35 );
    if (window.console) {
       console.log("Loading finished, scaling object by " + scale);
       console.log("Center at ( " + centerX + ", " + centerY + ", " + centerZ + " )");
    }
    
    /* Create the wrapper, model, to scale and rotate the object. */
    
    model = new THREE.Object3D();
    model.add(object);
    model.scale.set(scale,scale,scale);
    model.rotation.set(rotation[0],rotation[1],rotation[2]);
	
    scene.add(model);
    render();
	//update()
}


function animate() 
{
    requestAnimationFrame( animate );
	render();		
	update();
}


function update()
{

	var rotateAngle = Math.PI / 16 * clock.getDelta();   // pi/8 radians  per second
	var moveDistance = 200 * clock.getDelta();

	// if (disc.position == model.position){
	// 	alert("You made it in the hole!");
	// }
	if (disc.position.y == -3){
		alert("Take another throw");
		disc.position.y = 40;
		//move camera
	}
	if ( keyboard.pressed("1") ) 
	{ 
		// View of Hole
		camera.position.set(0,20,1000);
	}
	else if ( keyboard.pressed("2") ) 
	{ 
		// View from Above
		camera.position.set(0,5000,0);
	}
	else if ( keyboard.pressed("3") ) 
	{ 
		// View from Behind disc
		camera.position.set(0,50,2000);
	}	

	//rotate direction arrow
	// var rotation_matrix = new THREE.Matrix4().identity();
	if (keyboard.pressed("A")){
		// pyramid.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle); 
		disc.rotation.y +=rotateAngle;
		directionAngle -=rotateAngle;
	}
	else if ( keyboard.pressed("D") ) {
		// pyramid.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
		disc.rotation.y -=rotateAngle;
		directionAngle += rotateAngle;
	}
	if (keyboard.pressed("W")){
		disc.rotation.x += rotateAngle;
		tiltAngle += rotateAngle;
	}
	else if (keyboard.pressed("S")){
		disc.rotation.x -= rotateAngle;
		tiltAngle -= rotateAngle;
	}


	if ( keyboard.pressed("space") ){
		pyramid.material.opacity = 0;
		pyramid.material.transparent = true;
		if ( disc.position.y >= -3) {
			// movement = disc_movement( power, wind, ychange) 
			// disc.position.x += movement[0]
			// disc.position.y += movement[1]
			// disc.position.z += movement[2]
			disc_movement();
		}
	
	}
	// if (disc.position.y <= -2){
	// 	alert("Ready for next throw!");
	// 	disc.position.y = 40;
	// 	camera.position.y = 50;
	// 	pyramid.material.opacity = 1;
	// 	pyramid.material.transparent = false;	
	// }
	// if ( (disc.position.x == frishole.position.x) && (disc.position.z == frishole.position.z) ){
	// 	alert("Nice throw! Move on to the next hole!");
	// }

	controls.update();
	stats.update();
}



function disc_movement() {
	x = (powerdisc * directionAngle) + wind;
	z = powerdisc*.5;
	y = powerdisc*tiltAngle - gravity;
	
	gravity += .05

	disc.position.z -= z;
	disc.position.y += y;
	disc.position.x += x;

	camera.position.z -= z;
	camera.position.y += y;
	camera.position.x += x;
	// movementy = powerdisc*.01 * ychange
	// ychange = ychange - .02
	
	
	
	// return [0,movementy,-powerdisc*.1]
	
	
	
	
}	
	
	
	
function render() 
{
	renderer.render( scene, camera );
}

</script>

</body>
</html>
