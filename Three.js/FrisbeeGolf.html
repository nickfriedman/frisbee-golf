<!doctype html>
<html lang="en">
<head>
	<title>Frisbee Golf</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body>

<script src="js/Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<!-- <script src='threex.grass.js'></script>
 -->
<script type='text/javascript' src='js/DAT.GUI.min.js'></script>


<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>


// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
// custom global variables
var model = null;

var modelDirectory = "models/";
var disc;
var pyramid;

var ychange = 1;
var powerdisc = 50;


init();
animate();

// FUNCTIONS 		
function init() 
{
	// SCENE
	scene = new THREE.Scene();
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(0,50,2000);
	camera.lookAt(scene.position);	
	// RENDERER
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
		renderer = new THREE.CanvasRenderer(); 
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	// LIGHT
	var light = new THREE.PointLight(0xffffff);
	light.position.set(0,250,0);
	scene.add(light);
	// FLOOR
	THREE.ImageUtils.crossOrigin = '';
	var floorTexture = THREE.ImageUtils.loadTexture('images/grass-512.jpg');
	// var floorTexture = new THREE.ImageUtils.loadTexture( 'images/grass.jpg' );
	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
	floorTexture.repeat.set( 10, 10 );
	var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneGeometry(5000, 5000, 10, 10);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.position.y = -5;
	floor.rotation.x = Math.PI / 2;
	scene.add(floor);


	////////////
	// CUSTOM //
	////////////
	
	// axes
	var axes = new THREE.AxisHelper(100);
	scene.add( axes );
	
	var imagePrefix = "images/nightsky_";
	var directions  = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
	var imageSuffix = ".png";
	var skyGeometry = new THREE.CubeGeometry( 5000, 5000, 5000 );

	
	
	var materialArray = [];
	for (var i = 0; i < 6; i++)
		materialArray.push( new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
			side: THREE.BackSide
		}));
	var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
	var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
	scene.add( skyBox );
	

	var shapeMaterial = new THREE.MeshPhongMaterial( { color:0xff0000, transparent:true, opacity:1 } );

	var shapeMaterial = new THREE.MeshPhongMaterial( { color:0xff0000, transparent:false, opacity:1 } );

	
	//add frisbee stuff
	installModel(0);
	

	var geometry = new THREE.CylinderGeometry( 10, 10, 1, 60 );
	var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
    disc = new THREE.Mesh( geometry, material );
	disc.position.set(0,40,1900);
	scene.add( disc );

	// pyramid
	pyramid = new THREE.Mesh( 
		// radiusAtTop, radiusAtBottom, height, segmentsAroundRadius, segmentsAlongHeight,
		new THREE.CylinderGeometry( 0, 5, 80, 3, 4 ), 
		shapeMaterial );
	pyramid.position.set(0, 3, -50);
	pyramid.rotateOnAxis( new THREE.Vector3(1,0,0), 275);
	disc.add( pyramid );

	var gui = new dat.GUI();
	var parameters = 
	{
		a: 5, // numeric slider
		p: 50, //numeric slider
		b: false, //boolean (checkbox)
		c: true, // boolean (checkbox)
		d: "#ffff00", // color (hex)
		x: 0, y: 0, z: 0
	};
	// gui.add( parameters )
	gui.add( parameters, 'a' ).min(0).max(100).step(10).name('Wind');
	// gui.add( parameters, 'c' ).name('Night Mode');

	var power = gui.add( parameters, 'p').min(0).max(100).step(10).name('Power').listen();
	power.onChange( function(value) {
		powerdisc = value;
		
	});
	var daysky = gui.add( parameters, 'b').name("Day Mode").listen();
	daysky.onChange( function(value) {
		if(value) {
			// daysky.setValue(true);
			// nightsky.setValue(false);
			imagePrefix = "images/dawnmountain-";

			for (var i = 0; i < 6; i++)
				materialArray.push( new THREE.MeshBasicMaterial({
					map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
					side: THREE.BackSide
				}));
			skyMaterial = new THREE.MeshFaceMaterial( materialArray );
			skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
			scene.add( skyBox );
		}
	});

	var nightsky = gui.add( parameters, 'c').name('Night Mode').listen();
	nightsky.onChange( function(value) {
		if (value) {
			// nightsky.setValue(true);
			// daysky.setValue(false);
			imagePrefix = "images/nightsky_";

			for (var i = 0; i < 6; i++)
				materialArray.push( new THREE.MeshBasicMaterial({
					map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
					side: THREE.BackSide
				}));
			skyMaterial = new THREE.MeshFaceMaterial( materialArray );
			skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
			scene.add( skyBox );
		}
	});

	// gui.addColor( parameters, 'd' ).name('Disk Color');
	var discColor = gui.addColor( parameters, 'd' ).name('Disk Color').listen();
	discColor.onChange(function(value)
	{disc.material.color.setHex( value.replace("#", "0x") );  });
	
	var folder1 = gui.addFolder('Coordinates');
	folder1.add( parameters, 'x' );
	folder1.add( parameters, 'y' );
	folder1.add( parameters, 'z' );
	folder1.close();




	gui.open();
	
}


function installModel(modelNumber) {
    function callback(geometry,material) {  // callback function to be executed when loading finishes.
        modelLoaded(geometry, [0,0,0]);
        //document.getElementById("status").innerHTML = "";
        
    }
    if (model) {
        scene.remove(model);
    }
    //document.getElementById("status").innerHTML = "Loading<br>" + "frisbee.json";
    var loader = new THREE.JSONLoader();
    try {
        loader.load(modelDirectory + "frishole.json", callback);
    }
    catch (e) {
        // Note: Will give an error if loading from the local file system
        // on some browsers (Chrome, at least). 
        document.getElementById("status").innerHTML =
            "Could not<br>load model!<br><br>Note that<br>some browsers<br>cannot load<br>models from<br>a local disk.";
    }
}

function modelLoaded(geometry, rotation) {

    /* create the object from the geometry was loaded, with a white material. */
       
    var object = new THREE.Mesh(geometry,
                        new THREE.MeshLambertMaterial( {color:"white"} ));

    /* Determine the ranges of x, y, and z in the vertices of the geometry. */

    var xmin = Infinity;
    var xmax = -Infinity;
    var ymin = Infinity;
    var ymax = -Infinity;
    var zmin = Infinity;
    var zmax = -Infinity;
    for (var i = 0; i < geometry.vertices.length; i++) {
        var v = geometry.vertices[i];
        if (v.x < xmin)
            xmin = v.x;
        else if (v.x > xmax)
            xmax = v.x;
        if (v.y < ymin)
            ymin = v.y;
        else if (v.y > ymax)
            ymax = v.y;
        if (v.z < zmin)
            zmin = v.z;
        else if (v.z > zmax)
            zmax = v.z;
    }
    
    /* translate the center of the object to the origin */
    var centerX = (xmin+xmax)/2;
    var centerY = (ymin+ymax)/2; 
    var centerZ = (zmin+zmax)/2;
    var max = Math.max(centerX - xmin, xmax - centerX);
    max = Math.max(max, Math.max(centerY - ymin, ymax - centerY) );
    max = Math.max(max, Math.max(centerZ - zmin, zmax - centerZ) );
    var scale = 50/max;
    object.position.set( -centerX, -centerY+1, -centerZ+35 );
    if (window.console) {
       console.log("Loading finished, scaling object by " + scale);
       console.log("Center at ( " + centerX + ", " + centerY + ", " + centerZ + " )");
    }
    
    /* Create the wrapper, model, to scale and rotate the object. */
    
    model = new THREE.Object3D();
    model.add(object);
    model.scale.set(scale,scale,scale);
    model.rotation.set(rotation[0],rotation[1],rotation[2]);
	
    scene.add(model);
    render();
	//update()
}


function animate() 
{
    requestAnimationFrame( animate );
	render();		
	update();
}


function update()
{
	var rotateAngle = Math.PI / 16 * clock.getDelta();   // pi/8 radians  per second
	var moveDistance = 200 * clock.getDelta();


	if ( keyboard.pressed("1") ) 
	{ 
		// View of Hole
		camera.position.set(0,20,1000);
	}
	else if ( keyboard.pressed("2") ) 
	{ 
		// View from Above
		camera.position.set(0,5000,0);
	}
	else if ( keyboard.pressed("3") ) 
	{ 
		// View from Behind disk
		camera.position.set(0,50,2000);
	}	

	
	if ( keyboard.pressed("left") ){
		disc.position.x -= moveDistance;
	}
	if ( keyboard.pressed("right") )
		disc.position.x += moveDistance;
	if ( keyboard.pressed("down") )
		disc.position.z += moveDistance;
	if ( keyboard.pressed("up") )
		disc.position.z -= moveDistance;
	power= 50
	wind = (0,0,0)
	if ( keyboard.pressed("space") ){
		if ( disc.position.y >=30) {
			movement = disc_movement( power, wind, ychange) 
			disc.position.x += movement[0]
			disc.position.y += movement[1]
			disc.position.z += movement[2]
			
			
			
			controls.update();
			stats.update();
			}
	
		}

	


	//rotate direction arrow
	// var rotation_matrix = new THREE.Matrix4().identity();
	if (keyboard.pressed("A")){
		// pyramid.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle); 
		disc.rotation.y +=rotateAngle;
	}
	else if ( keyboard.pressed("D") ) {
		// pyramid.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
		disc.rotation.y -=rotateAngle;
	}
	if (keyboard.pressed("W")){
		disc.rotation.x += rotateAngle;
	}
	else if (keyboard.pressed("S")){
		disc.rotation.x -= rotateAngle;
	}
	controls.update();
	stats.update();
}



function disc_movement( power, wind, ychange1) {
	movementy = powerdisc*.01 * ychange
	ychange = ychange - .02
	
	
	
	return [0,movementy,-powerdisc*.1]
	
	
	
	
}	
	
	
	
function render() 
{
	renderer.render( scene, camera );
}

</script>

</body>
</html>
