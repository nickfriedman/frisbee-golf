<!doctype html>
<html lang="en">
<head>
	<title>Frisbee Golf</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body>

<script src="js/Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src='js/threex.grass.js'></script>

<script type='text/javascript' src='js/DAT.GUI.min.js'></script>

<!-- load fonts -->
<script src="fonts/gentilis_bold.typeface.js"></script>
<script src="fonts/gentilis_regular.typeface.js"></script>
<script src="fonts/optimer_bold.typeface.js"></script>
<script src="fonts/optimer_regular.typeface.js"></script>
<script src="fonts/helvetiker_bold.typeface.js"></script>
<script src="fonts/helvetiker_regular.typeface.js"></script>
<script src="fonts/droid_sans_regular.typeface.js"></script>
<script src="fonts/droid_sans_bold.typeface.js"></script>
<script src="fonts/droid_serif_regular.typeface.js"></script>
<script src="fonts/droid_serif_bold.typeface.js"></script>

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>


// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
// custom global variables
var model = null;

var modelDirectory = "models/";
var disc;
var pyramid;
var Score = 0;

var ychange = 1;
var gravity = 2;
var powerdisc = 50;
var directionAngle = 0;
var tiltAngle = 0;
var wind = 0;
var gameNotOver = true;
var level1 = true;
var skyboxlist = [];

var holex=0;
var holey=30;
var holez=0;

var InHole=0;


init();
animate();
// while (gameNotOver){
// 	while (level1){
// 		if (disc.position == model.positions){
// 			alert("You made it in the hole!");
// 			break;
// 		}
// 		else if (disc.position.y == -3){
// 			alert("Take another throw");
// 			disc.position.y = 40;
// 			//move camera
// 		}
// 	}
// }



// FUNCTIONS 		
function init() 
{
	// SCENE
	scene = new THREE.Scene();
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(0,50,2000);
	camera.lookAt(scene.position);	
	// RENDERER
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
		renderer = new THREE.CanvasRenderer(); 
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	// LIGHT
	var light = new THREE.PointLight(0xffffff, 1, 0 , 2);
	light.position.set(0,1250,0);
	scene.add(light);
	//ambient light
	var light2 = new THREE.AmbientLight(0x333333, 1, 0 , 2); 
	light2.position.set( light.position );
	scene.add(light2);
	// FLOOR
	THREE.ImageUtils.crossOrigin = '';
	var floorTexture = THREE.ImageUtils.loadTexture('images/grass-512.jpg');
	// var floorTexture = new THREE.ImageUtils.loadTexture( 'images/grass.jpg' );
	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
	floorTexture.repeat.set( 10, 10 );
	var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneGeometry(5000, 5000, 10, 10);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.position.y = -5;
	floor.rotation.x = Math.PI / 2;
	scene.add(floor);


	////////////
	// CUSTOM //
	////////////
	
	// axes
	var axes = new THREE.AxisHelper(100);
	scene.add( axes );
/*
	//3d grass
	var nTufts	= 5000
	var positions	= new Array(nTufts)
	for(var i = 0; i < nTufts; i++){
		var gposition	= new THREE.Vector3()
		gposition.x	= (Math.random()-0.5)*20
		gposition.z	= (Math.random()-0.5)*20
		positions[i]	= gposition
	}
	var mesh	= THREEx.createGrassTufts(positions)
	scene.add(mesh)

	// load the texture
	var textureUrl		= THREEx.createGrassTufts.baseUrl+'images/grass01.png'
	var material		= mesh.material
	material.map		= THREE.ImageUtils.loadTexture(textureUrl)
	material.alphaTest	= 0.7
*/
	//skybox

	var imagePrefix = "images/nightsky_";
	var imagePrefixDay = "images/dawnmountain-";
	skyboxload(imagePrefix);
	skyboxload(imagePrefixDay);
	for (var i =0; i<skyboxlist.length; i++){
		scene.add(skyboxlist[i]);
	}

	var shapeMaterial = new THREE.MeshPhongMaterial( { color:0xff0000, transparent:true, opacity:1 } );

	var shapeMaterial = new THREE.MeshPhongMaterial( { color:0xff0000, transparent:false, opacity:1 } );

	
	//add frisbee stuff
	installModel(0);

	var geometry = new THREE.CylinderGeometry( 10, 10, 1, 60 );
	var material = new THREE.MeshLambertMaterial( {color: 0xffff00} );
    disc = new THREE.Mesh( geometry, material );
	disc.position.set(0,40,1900);
	var discLight = new THREE.AmbientLight(0x333333); 
	discLight.position.set( disc.position );
	disc.add(discLight);	
	scene.add( disc );

	// pyramid
	pyramid = new THREE.Mesh( 
		// radiusAtTop, radiusAtBottom, height, segmentsAroundRadius, segmentsAlongHeight,
		new THREE.CylinderGeometry( 0, 5, 80, 3, 4 ), 
		shapeMaterial );
	pyramid.position.set(0, 3, -50);
	pyramid.rotateOnAxis( new THREE.Vector3(1,0,0), 275);
	disc.add( pyramid );

	// add 3D text
	var materialFront = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
	var materialSide = new THREE.MeshBasicMaterial( { color: 0x000088 } );
	var materialArray = [ materialFront, materialSide ];
	var textGeom = new THREE.TextGeometry( "Score: 0   Par: 3", 
	{
		size: 60, height: 4, curveSegments: 3,
		font: "helvetiker", weight: "bold", style: "normal",
		bevelThickness: 1, bevelSize: 2, bevelEnabled: true,
		material: 0, extrudeMaterial: 1
	});
	// font: helvetiker, gentilis, droid sans, droid serif, optimer
	// weight: normal, bold
	
	var textMaterial = new THREE.MeshFaceMaterial(materialArray);
	var textMesh = new THREE.Mesh(textGeom, textMaterial );
	
	textGeom.computeBoundingBox();
	var textWidth = textGeom.boundingBox.max.x - textGeom.boundingBox.min.x;
	
	textMesh.position.set( -0.5 * textWidth, 500, 100 );
	textMesh.rotation.x = Math.PI / 4;
	scene.add(textMesh);

	var gui = new dat.GUI();
	var parameters = 
	{
		a: 0, // numeric slider
		p: 50, //numeric slider
		b: false, //boolean (checkbox)
		c: true, // boolean (checkbox)
		d: "#ffff00", // color (hex)
		x: 0, y: 0, z: 0,
		reset: function(){ resetDisc()}
	};
	// gui.add( parameters )
	var winds = gui.add( parameters, 'a' ).min(0).max(50).step(5).name('Wind').listen();
	winds.onChange( function(value) {
		wind = value;
	})

	var power = gui.add( parameters, 'p').min(0).max(70).step(5).name('Power').listen();
	power.onChange( function(value) {
		powerdisc = value;
	});

	var daysky = gui.add( parameters, 'b').name("Day Mode").listen();
	daysky.onChange( function(value) {
		
		if(value) {
			// scene.remove( skyBox);
			nightsky.setValue(false);
			// scene.add( skyBoxDay)
			scene.remove( skyboxlist[0]);
			scene.add( skyboxlist[1]);
			disc.remove(discLight);
		}
	});

	var nightsky = gui.add( parameters, 'c').name('Night Mode').listen();
	nightsky.onChange( function(value) {
		if (value) {
			// scene.remove( skyBoxDay);
			daysky.setValue(false);
			// scene.add( skyBox);
			scene.remove( skyboxlist[1]);
			scene.add( skyboxlist[0]);
			disc.add(discLight);
		}
	});

	var discColor = gui.addColor( parameters, 'd' ).name('Disc Color').listen();
	discColor.onChange(function(value)
	{disc.material.color.setHex( value.replace("#", "0x") );  });
	
	var folder1 = gui.addFolder('Coordinates');
	folder1.add( parameters, 'x' );
	folder1.add( parameters, 'y' );
	folder1.add( parameters, 'z' );
	folder1.close();

	gui.add( parameters, 'reset' ).name("Reset Disc").listen();





	gui.open();
	
}

function skyboxload(imagePrefix){
	var directions  = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
	var imageSuffix = ".png";
	var skyGeometry = new THREE.CubeGeometry( 5000, 5000, 5000 );

	var materialArray = [];
	for (var i = 0; i < 6; i++)
		materialArray.push( new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
			side: THREE.BackSide
		}));
	var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
	var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
	skyboxlist.push(skyBox);
	// scene.add( skyBox );

}

function resetDisc(){
	console.log("in reset");

	/*
	parameters.a = 0;
	parameters.p = 50; //numeric slider
	parameters.b = false; //boolean (checkbox)
	parameters.c = true; // boolean (checkbox)
	parameters.d = "#ffff00"; // color (hex)
	parameters.x = 0;
	parameters.y = 0;
	parameters.z = 0;
	*/
	Score ++;

	ychange = 1;
	gravity = 2;
	//powerdisc = 50;
	directionAngle = 0;
	tiltAngle = 0;
	//wind = 0;
	gameNotOver = true;
	level1 = true;
	InHole = 0;

<<<<<<< HEAD
	disc.position.y = 40;
	camera.position.y = 50;
	if (disc.position.x > 0)
		camera.position.x = disc.position.x + (disc.position.x /1900)*200;
	else if (disc.position.x < 0)
		camera.position.x = disc.position.x + (disc.position.x /1900)*200;
	else
		camera.position.x =0;
	if (disc.position.z > 0)
		camera.position.z = disc.position.z + (disc.position.z /1900)*200;
	else (disc.position.z < 0)
		camera.position.z = disc.position.z + (disc.position.z /1900)*200;
=======
	// disc.position.x = 0
	// disc.position.y = 40
	// disc.position.z = 1900;
	// disc.rotation.x = 0;
	// disc.rotation.y = 0;
	m = (model.position.x -disc.position.x) / (model.position.z - disc.position.z)
	camera.position.x = m * (camera.position.z + 100 - disc.position.z) + disc.position.x;
	camera.position.z = 100 + disc.position.z;

	disc.position.y = 40;
	camera.position.y = 50;
	// if (disc.position.x > 0)
	// 	camera.position.x = disc.position.x + 100;
	// else if (disc.position.x < 0)
	// 	camera.position.x = disc.position.x - 100;
	// else
	// 	camera.position.x =0;
	// if (disc.position.z > 0)
	// 	camera.position.z = disc.position.z + 100;
	// else (disc.position.z < 0)
	// 	camera.position.z = disc.position.z - 100;
>>>>>>> origin/master
	console.log(disc.position.x);
	console.log(camera.position.x);
	console.log(disc.position.z);
	console.log(camera.position.z);
	camera.lookAt(model.position);
	// pyramid.position.set(0, 3, -50);
	pyramid.material.transparent = false;
	pyramid.material.opacity = 1;
	//pyramid.rotateOnAxis( new THREE.Vector3(1,0,0), 275);

	// camera.position.set(0,50,2000);




}

function installModel(modelNumber) {
    function callback(geometry,material) {  // callback function to be executed when loading finishes.
        modelLoaded(geometry, [0,0,0]);
        //document.getElementById("status").innerHTML = "";
        
    }
    if (model) {
        scene.remove(model);
    }
    //document.getElementById("status").innerHTML = "Loading<br>" + "frisbee.json";
    var loader = new THREE.JSONLoader();
    try {
        loader.load(modelDirectory + "frishole.json", callback);
    }
    catch (e) {
        // Note: Will give an error if loading from the local file system
        // on some browsers (Chrome, at least). 
        document.getElementById("status").innerHTML =
            "Could not<br>load model!<br><br>Note that<br>some browsers<br>cannot load<br>models from<br>a local disk.";
    }
}

function modelLoaded(geometry, rotation) {

    /* create the object from the geometry was loaded, with a white material. */
       
    var object = new THREE.Mesh(geometry,
                        new THREE.MeshLambertMaterial( {color:"white"} ));

    /* Determine the ranges of x, y, and z in the vertices of the geometry. */

    var xmin = Infinity;
    var xmax = -Infinity;
    var ymin = Infinity;
    var ymax = -Infinity;
    var zmin = Infinity;
    var zmax = -Infinity;
    for (var i = 0; i < geometry.vertices.length; i++) {
        var v = geometry.vertices[i];
        if (v.x < xmin)
            xmin = v.x;
        else if (v.x > xmax)
            xmax = v.x;
        if (v.y < ymin)
            ymin = v.y;
        else if (v.y > ymax)
            ymax = v.y;
        if (v.z < zmin)
            zmin = v.z;
        else if (v.z > zmax)
            zmax = v.z;
    }
    
    /* translate the center of the object to the origin */
    var centerX = (xmin+xmax)/2;
    var centerY = (ymin+ymax)/2; 
    var centerZ = (zmin+zmax)/2;
    var max = Math.max(centerX - xmin, xmax - centerX);
    max = Math.max(max, Math.max(centerY - ymin, ymax - centerY) );
    max = Math.max(max, Math.max(centerZ - zmin, zmax - centerZ) );
    var scale = 50/max;
    object.position.set( -centerX, -centerY+1, -centerZ );
    if (window.console) {
       console.log("Loading finished, scaling object by " + scale);
       console.log("Center at ( " + centerX + ", " + centerY + ", " + centerZ + " )");
    }
    
    /* Create the wrapper, model, to scale and rotate the object. */
    
    model = new THREE.Object3D();
    model.add(object);
    model.scale.set(scale,scale,scale);
    model.rotation.set(rotation[0],rotation[1],rotation[2]);
	
    scene.add(model);
    render();
	//update()
}


function animate() 
{
    requestAnimationFrame( animate );
	render();		
	update();
}


function update()
{

	var rotateAngle = Math.PI / 16 * clock.getDelta();   // pi/8 radians  per second

	// if (disc.position == model.position){
	// 	alert("You made it in the hole!");
	// }
	if (disc.position.y == -3){
		alert("Take another throw");
		disc.position.y = 40;
		//move camera
	}
	if ( keyboard.pressed("1") ) 
	{ 
		// View of Hole
		camera.position.set(0,20,500);
	}
	else if ( keyboard.pressed("2") ) 
	{ 
		// View from Above
		camera.position.set(0,5000,0);
	}
	else if ( keyboard.pressed("3") ) 
	{ 
		// View from Behind disc
		camera.position.set(0,50,2000);
	}	

	//rotate direction arrow
	// var rotation_matrix = new THREE.Matrix4().identity();
	if (keyboard.pressed("A")){
		// pyramid.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle); 
		disc.rotation.y +=rotateAngle;
		directionAngle -=rotateAngle;
	}
	else if ( keyboard.pressed("D") ) {
		// pyramid.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
		disc.rotation.y -=rotateAngle;
		directionAngle += rotateAngle;
	}
	if (keyboard.pressed("W")){
		disc.rotation.x += rotateAngle;
		tiltAngle += rotateAngle;
	}
	else if (keyboard.pressed("S")){
		disc.rotation.x -= rotateAngle;
		tiltAngle -= rotateAngle;
	}


	if ( keyboard.pressed("space") ){
		pyramid.material.opacity = 0;
		pyramid.material.transparent = true;
		if ( disc.position.y >= -3 && InHole==0) {
			// movement = disc_movement( power, wind, ychange) 
			// disc.position.x += movement[0]
			// disc.position.y += movement[1]
			// disc.position.z += movement[2]
			disc_movement();
		}
	
	}
	// if (disc.position.y <= -2){
	// 	alert("Ready for next throw!");
	// 	disc.position.y = 40;
	// 	camera.position.y = 50;
	// 	pyramid.material.opacity = 1;
	// 	pyramid.material.transparent = false;	
	// }
	// if ( (disc.position.x == frishole.position.x) && (disc.position.z == frishole.position.z) ){
	// 	alert("Nice throw! Move on to the next hole!");
	// }

	controls.update();
	stats.update();
}



function disc_movement() {

	x = (powerdisc * directionAngle) + wind*0.5;
	z = powerdisc*.5;
	y = powerdisc*tiltAngle - gravity;
	
	gravity += .05

	disc.position.z -= z;
	disc.position.y += y;
	disc.position.x += x;

	//TRYING TO ADD PARTICLE SYSTEM
	var particleCount = 10,
	    particles = new THREE.Geometry(),
		pMaterial = new THREE.ParticleBasicMaterial({
			color: 0xFFFFFF,
			size: 10,
			map: THREE.ImageUtils.loadTexture(
				"images/particle.png"
			),
			blending: THREE.AdditiveBlending,
			transparent: true
		});
	
	// now create the individual particles
	for(var p = 0; p < particleCount; p++) {
	
		// create a particle with random
		// position values
		var pX = Math.random() * 10 - 5 ,
			pY = Math.random() * 10 - 5,
			pZ = Math.random() * 10 - 5,
		    particle = new THREE.Vertex(
				new THREE.Vector3(disc.position.x + pX, disc.position.y + pY, disc.position.z + pZ)
			);

		// add it to the geometry
		particles.vertices.push(particle);
	}
	
	// create the particle system
	var particleSystem = new THREE.ParticleSystem(
		particles,
		pMaterial);
	
	particleSystem.sortParticles = true;
	
	// add it to the scene
	scene.add(particleSystem);
	//
		
	//&& (holey-2 < disc.position.y <holey+2) && (holez-2 < disc.position.z <holez+2)
	if (holez-30 < disc.position.z && disc.position.z<holez+30 && holex-30 < disc.position.x && disc.position.x<holex+30 && holey-30 < disc.position.y && disc.position.y<holey+30){
		InHole=1;
		alert("Made it!");
		}

	camera.position.z -= 0.75 * z;
	camera.position.y += y;
	camera.position.x += x;
	camera.lookAt(disc.position)

	
	
}	
	
	
	
function render() 
{
	renderer.render( scene, camera );
}

</script>

</body>
</html>
